# 线程安全性

## 原子性

### 竞态条件

出现线程安全问题的一个原因。

概念：基于一种可能失效的观察结果来做出判断或者执行某个计算。

### 复合操作

如：“先检查后执行”、“读取——修改——写入”

概念：包含了一组必须以原子方式执行的操作以确保线程安全性。

## 加锁机制

### 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为又这个锁保护的代码块。以关键词synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。

内置锁过于极端，存在性能问题。

### 重入锁

当某个线程请求一个由其他线程持有的锁时，发出请求的线程会阻塞。

内置锁是可以重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那个这个请求就会成功。

概念：重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

## 用锁来保护状态

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

## 活跃性与性能

通过缩小同步代码块的作用范围，可以很容易的做到既确保程序并发性，又维护线程安全性。要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。

无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。