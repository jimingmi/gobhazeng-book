# 面试题

## 阿里

1. dubbo的底层负载均衡，容错机制都是怎么实现的
2. Dubbo实现了远端rpc调用，请手写一个rpc调用
3. Redis为什么可以实现分布式锁，memcached可以实现分布式锁么？实现分布式锁的方式有很多种，为什么选择redis分布式锁？

**Redis为什么可以实现分布式锁？**

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。
同时Redis的读写性能很高，其自身提供的`SETNX`和`GETSET`也使得Redis很容易去实现分布式锁。

**memcached可以实现分布式锁么？**

4. in-jvm（必考）以及jmm缓存模型如何调优?
5. Concurrenthashmap为什么要用红黑树？（我已答出检索效率高），为何不用其他的树，平衡二叉树，b+？
6. 栈的特性先进后出。手写实现入栈出栈，获取栈的长度，栈是否为空。
7. 一个树，从根节点往下走，每条路径的节点值为某一数值，不管最后节点是不是叶子节点。写出具体实现方法。
8. 数据库的隔离级别
9. 数据库是怎么搭建集群的，主从数据同步怎么做的？
10. 如何给hashmap的key对象设计他的hashcode？
11. 场景式的问题:秒杀,能列出常见的排队、验证码、库存扣减方式对系统高并发的影响?
12. ExecutorService 线程池基础类

### 全局唯一有序ID

不能有单点故障。最好以时间为序，或者ID里包含时间。这样一是可以少一个索引，二是冷热数据容易分离。

可以控制`ShardingId`。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易。

不要太长，最好64bit。过长可能有的组件不支持。

如Twitter有比较好的实现——Snowflake，时间+节点标识+计数。

### 冯诺依曼体系

简单来说就是程序空间和数据空间是一体的。（哈佛体系是分开的）

 - 必须有一个存储器。
 - 必须有一个控制器。
 - 必须有一个运算器，用于完成算术运算和逻辑运算。
 - 必须有输入和输出设备，用于进行人机通信。

### shell 命令的执行过程

分层执行

 - 第一层，按照换行进行分段。
 - 第二层，判断管道“|”等特殊字符，得到基本的命令。
 - 解析参数，进行执行。

### 信息熵

 信息熵是消除不确定性所需信息量的度量，也即未知事件可能含有的信息量。

从数学角度上来看，信息熵其实是一个随机变量信息量的数学期望。

### 程序运行中的栈式结构，栈溢出攻击

《深入理解计算机系统》

### TCP/IP 有关知识。

TCP/IP 4层协议

### 同步与阻塞

这里有一个陷阱。同步与异步是一对关系，阻塞与非阻塞是一对关系，它们关注点也不同。

同步与异步关注的是消息通讯机制，阻塞与非阻塞关注的是程序在等待调用结果时的状态，总的看来同步与异步要比阻塞与非阻塞站在更高的角度。

异步则相反，调用在发出后就返回了，但并没有返回需要的结果，后续被调用者通过状态、通知等返回结果。

**异步就是异步，同步才会有阻塞与非阻塞。**

### 并行与并发

**并发(Concurrency)：**

并发是多个任务交替执行，对于外部观察者来说，即使多个任务是串行并发的，也会造成多任务间是并行执行的错觉，因为这种交替速度大大快于人类的反应。

**并行(Parallelism)：**

并行是真正意义上多个任务同时执行。

> 并发和并行的实际效果还受到CPU的限制，真正的并发只存在多CPU或多核CPU的系统中。

### Java 线程的本质

### 内核线程与用户线程

### 线程调度

### 并行级别

### 内核态与用户态，中断

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级**内核态**与**用户态**。

中断是多任务操作系统的重要机制，由于cpu数量总是小于并行任务执行数，所以cpu资源需要作为一种全局的资源让所有任务共享。根据进程调度算法，这里往往值基于时间片的优先调度算法，当一个任务（进程）的时间片到了之后，系统就需要执行中断操作

### CPU 与内存与磁盘



### 缓存行与伪共享

缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。

为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。

### 内存分配管理，段页式。jemalloc


### Java 程序的运行原理

 - 编辑源码
 - 编译生成class文件
 - 类加载器加载class文件
 - 找到main()方法入口，运行class字节码文件

### 普通可执行程序的运行原理

根据冯诺依曼的体系结构：

 - 1. 在控制器指挥下，从存储器上取出指令。
 - 2. 分析指令，得到计算命令和待操作的数。
 - 3. 从存储器上取出待计算的数放入运算器。
 - 4. 运算器计算结果。
 - 5. 输出到存储器或输出设备。

### 缓存行与伪共享

多核CPU会发生的问题。

Java的hotspot JVM中对象指针不会小于64KB，这会导致CPU快速缓存区存入多个对象指针。由于CPU只能写自己的快速缓存的资源，这就相当于给资源加了锁，导致另一个CPU不能访问同快速缓存区的其他资源。

对此Java的解决方案可以使用Disruptor，将缓存区直接写满64KB保证只有一个对象指针，不会产生类似锁竞争的情况。

### 从浏览器发出请求开始，到服务端应用接受到请求为止的过程


### HashMap ，hash 碰撞，hash 算法的优化


### 单点登录


### 正向代理与反向代理


### 反爬机制，爬虫模拟浏览器行为


### cglib 方法拦截

CGLIB实现的动态代理，完全不受代理类必须实现接口的限制，而且CGLIB底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLIB不能对声明为final的方法进行代理，因为CGLIB原理是动态生成被代理类的子类。

### 动态代理

动态代理方式是动态地生成具体委托类的代理类实现对象。

通过Proxy.newProxyInstance来创建代理的方法可以为不同的委托类都创建代理类。在具体的代理实现上，使用通用的实现，被代理的方法调用都会进入invoke()方法中，可以执行其他的事情。

动态代理本质上是利用JDK的反射实现的。

### 依赖注入



### Servlet 的本质


### TCP 长连接。心跳包，websocket


### Netty 百万级长连接优化


### DSL 解析到 AST 。lexer 和 parser


### JVM 相关


### 代码规范，包命名规范
