# 内核态与用户态

## 概念

**内核态(Kernel Mode): CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序**

**用户态(User Mode): 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取**

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级**内核态**与**用户态**。

## 用户态与内核态的切换

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作。

这时需要一个这样的机制: **用户态程序切换到内核态, 但是不能控制在内核态中执行的指令**。

这种机制叫**系统调用**, 在CPU中的实现称之为**陷阱指令(Trap Instruction)**。

他们的工作流程如下:

 - 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务。
 - 用户态程序执行陷阱指令。
 - CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问。
 - 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务。
 - 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果。
