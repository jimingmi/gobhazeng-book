# 数据结构、算法

# Java基础

## Java类执行顺序

- 如果父类有静态成员赋值或者静态初始化块，执行静态成员赋值和静态初始化块
- 如果类有静态成员赋值或者静态初始化块，执行静态成员赋值和静态初始化块
- 将类的成员赋予初值（原始类型的成员的值为规定值，例如int型为0，float型为0.0f，boolean型为false；对象类型的初始值为null）
- 如果构造方法中存在this()调用（可以是其它带参数的this()调用）则执行之，执行完毕后进入第7步继续执行，如果没有this调用则进行下一步。（这个有可能存在递归调用其它的构造方法）
- 执行显式的super()调用（可以是其它带参数的super()调用）或者隐式的super()调用（缺省构造方法），此步骤又进入一个父类的构造过程并一直上推至Object对象的构造。
- 执行类申明中的成员赋值和初始化块。
- 执行构造方法中的其它语句。

## Java类加载过程，类加载器

**类加载过程：**

- 载入：字节码生成class对象
- 校验：通过一定的方式校验class对象合法性（规范、正确初始化等）
- 准备：类变量（static）分配内存初始化，但还没有值
- 解析：常量的符号引用转化为直接引用
- 初始化：执行类构造器

**类加载器：**

启动类加载器：jre/lib

扩展类加载器：jre/lib/ext

应用类加载器：classpath

自定义类加载器

**双亲委派模型**

## JVM数据存储模型

- 程序计数器：标记java字节码执行位置
- java虚拟机栈：线程私有，每个方法执行都会创建一个栈帧，用于保存局部变量、操作栈、动态链接等
- 本地方法栈：为native方法提供服务
- java堆：线程共享，保存对象的实例
- 方法区：线程共享，类信息、常量、静态变量

## 新生代、年老代的构造

新生代：eden区域、from surviver区域、to surviver区域

老年代：JDK8前，存在持久代，在堆中；JDK8后，元空间取代持久代，在本地内存

## java GC算法，什么时候会触发minor gc，什么时候会触发full gc？

GC算法：复制算法、标记整理、标记清除

触发minor gc：eden空间不足、大对象分配eden

触发full gc：直接调用System.gc、空间分配担保失败（晋升到老年代的平均对象大小大于老年代的剩余大小）、老年代空间不足、持久代空间不足、元空间不足

## GC 可达性分析中哪些算是GC ROOT？

- 虚拟机栈引用
- 静态对象引用
- 常量引用
- native方法引用

## 你熟悉的JVM调优参数，使用过哪些调优工具？

最大堆内存、最小堆内存（调整一致，防止扩容）

设置元空间大小、设置堆外内存大小、dump堆内存异常日志

**工具：** 内置的 jstat、jmap、VisualVM

## Java 有什么锁类型?

公平、非公平：先等待锁是否可以先获得锁（fair、unfair）。

可重入锁：同一个线程在外层方法获取锁，在内层方法可直接获取锁（ReentrantLock）。

独享锁、共享锁：独享只可被一个线程持有；共享可以被多个线程持有，如ReadWriteLock，读是共享，写是独占。

乐观锁、悲观锁：设计思想，乐观锁认为数据一般不会发生修改，使用尝试更新的方式不断重试知道成功（CAS）；悲观锁认为资源一定会有安全问题，先进行加锁操作。

分段锁：通过分段加锁实现高效的锁并发操作，如ConcurrentHashMap。

偏向锁、轻量锁、重量锁：偏向即一直被一个线程获取锁；轻量即在锁是偏向锁时，其他线程尝试通过自旋获取锁，升级为轻量锁；当自旋到一定程度后，自旋不会无限进行下去，尝试获取锁的线程会被阻塞（挂起），升级为重量级锁，性能最差。

自旋锁：一种获取锁的方式，不断尝试获取锁，减少线程上下文切换的开销，但占用大量CPU时间片。

## 描述下线程池的处理流程？

java线程池的核心类是ThreadPoolExecutor，其核心是CTL：记录有效线程数量，线程状态

RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；

SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；

STOP状态：不再接受新任务，不处理队列中的任务

- 1.判断核心工作线程数是否满了，没满添加任务，满了进入下一阶段
- 2.判断工作队列是否满了，没满添加队列，满了进入下一阶段
- 3.判断最大核心工作线程是否满了，没满扩充任务，满了进入饱和处理

## hashmap是线程不安全的，concurrenthashmap是线程安全的，怎么实现的线程安全？

使用了分段锁与CAS，减少串行、阻塞、上下文切换

初始化操作，volatile保证可减少，通过标志位判断有无线程进行初始化，可通过yieid让出时间片（不是一定保证，也无法保证线程安全），之后通过CAS进行初始化操作

通过unsafe的volatile来保证node的可见性，之后进行加锁操作，在不考虑hash冲突的情况下，可以同时加16把锁，锁的粒度小，减少上下文切换和阻塞。

1.7是segment+hashmap分段 1.8是node

## volatile关键字解决了什么问题，实现原理是什么？

可见性，禁止指令重排

jmm内存模型，线程会从主存复制数据到工作内存，当改变内存数据值的时候只是改变了工作内存，还没有写入主存，如果是共享数据其他线程的工作内存里的值还是旧值。
volatile通过设置内存屏障，保证主存在拷贝到工作内存之前一定会将工作内存中的数据写入主存。

可以解决DCL（双重检查加锁）问题；线程退出的判断标识。

但不能解锁原子性问题，如i++不是一个原子操作。

## 并发容器有哪些,并发容器和同步容器的区别

**并发容器：**

ConcurrentHashMap：线程安全hashmap

CopyOnWriteArrayList：写时复制，线程安全且在读操作时无锁的ArrayList，占用内存，适合读多写少，不能保证数据一致性

ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制

LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue

**同步容器：**

Vector

HashTable

使用了同步锁

## 哪些库或者框架用到NIO

Netty使用NIO进行网络通信，Lettuce Redis连接池，DubboRPC

NIO是非阻塞

# Spring

## Spring 都有哪几种注入方式，什么情况下用哪种，ioc实现原理

接口、构造器、setter

ioc：控制反转，即创建调用者的过程由创建者转向容器。

实现原理：通过反射机制，从xml或者@bean构建beanfactory，之后可以通过beanfactory创建并注入对象。

## Spring Bean生命周期

![](_v_images/_1604337649_16499.png)




# MySQL

## 在工作中，SQL语句的优化和注意的事项

减少使用宽表，减少使用表关联（按业务，通过DDD拆分）

设置合理的索引，考虑覆盖索引（使用联合索引，在一个索引树获取数据，减少回表次数）

## 如何定位一个慢查询，一个服务有多条SQL你怎么快速定位

慢查询日志、连接池慢查询日志

## 聚集索引和非聚集索引知道吗？什么情况用聚集索引什么情况用非聚集索引

聚集索引：该索引可以直接定位到表中相应行的物理顺序，即可以理解为通过索引查到一个值的行后可以直接获取到整行的数据。

非聚集索引：该索引的逻辑顺序与磁盘上行的物理存储顺序不同，即可以理解为索引树（b+tree）上的叶子节点存储的是主键id数据，而非具体数据，之后可以通过主键id走聚集索引获取数据，这个过程即回表操作。

优化的过程即索引覆盖，即使用覆盖索引。 使用聚合索引可以不需要二次回表，但需要注意最左覆盖原则。

何时用聚集索引：小数目的、有范围的不同值

何时用非聚集索引：大小数目的、频繁更新的值

# Redis

## Nosql引擎用的什么存储结构，关系型数据库和NoSQL各自的优劣点是什么，如何技术选型？

# Zookeeper

# Netty

# 微服务












