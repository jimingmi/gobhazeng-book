# Proxy

## 静态代理

静态代理方式是为每个被代理的对象构造对应的代理类。

```java
//Calculator.java 接口
public interface Calculator {
	public int add(int a,int b);
}

//CalculatorImpl.java 实现类
public class CalculatorImpl implements Calculator {

	@Override
	public int add(int a, int b) {
		int i = a +b;
		System.out.println("result:"+i);
		return i;

	}

}

//CalculatorProxy.java 代理类
public class CalculatorProxy {

	private Calculator calculator;

	public CalculatorProxy(Calculator calculator) {
		this.calculator = calculator;
	}

	public int add(int a,int b){
		//doAfter
		System.out.println("doAfter");

		int result = calculator.add(a, b);

		//doBefore
		System.out.println("doBefore");

		return result;

	}

}

//TestStatic.java 测试
public class TestStatic {

	public static void main(String[] args) {
		CalculatorProxy proxy = new CalculatorProxy(new CalculatorImpl());

		proxy.add(1, 2);
	}

}

```

## 动态代理

动态代理方式是动态地生成具体委托类的代理类实现对象。

通过`Proxy.newProxyInstance`来创建代理的方法可以为不同的委托类都创建代理类。在具体的代理实现上，使用通用的实现，被代理的方法调用都会进入`invoke()`方法中，可以执行其他的事情。

```java
//Calculator.java 接口
public interface Calculator {
	public int add(int a,int b);
}

//CalculatorImpl.java 实现类
public class CalculatorImpl implements Calculator {

	@Override
	public int add(int a, int b) {
		int i = a +b;
		System.out.println("result:"+i);
		return i;

	}

}

//LogHandler.java 动态代理Handler
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class LogHandler implements InvocationHandler {

	private Object obj;

	public LogHandler(Object obj) {
		this.obj = obj;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		this.doBefore();
		Object o = method.invoke(obj, args);
		this.doAfter();
		return o;
	}

	public void doBefore() {

		System.out.println("doSomething-before");

	}

	public void doAfter() {

		System.out.println("doSomething-after");
	}

}

//TestDynamic.java 测试
import java.lang.reflect.Proxy;

public class TestDynamic {

	public static void main(String[] args) {
		Calculator calculator = new CalculatorImpl();

		LogHandler handler = new LogHandler(calculator);

		Calculator proxy = (Calculator) Proxy.newProxyInstance(calculator.getClass().getClassLoader(),
				calculator.getClass().getInterfaces(), handler);

		proxy.add(1, 2);

	}

}
```