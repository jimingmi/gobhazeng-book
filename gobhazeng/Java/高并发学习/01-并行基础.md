## 概念

### 方法调用

**同步方法(Synchronous)：**

同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。

**异步方法(Asynchronous)：**

异步方法更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中“真实”地执行。整个过程，不会阻碍调用者的工作。

### 多任务执行

**并发(Concurrency)：**

并发是多个任务交替执行，对于外部观察者来说，即使多个任务是串行并发的，也会造成多任务间是并行执行的错觉，因为这种交替速度大大快于人类的反应。

**并行(Parallelism)：**

并行是真正意义上多个任务同时执行。

> 并发和并行的实际效果还受到CPU的限制，真正的并发只存在多CPU或多核CPU的系统中。

### 公共资源

**临界区：**

临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程想要使用这个资源，就必须等待。

在并行程序中，临界区资源是重点保护的对象，如果被两个线程占用就很容易出现错误。

### 多线程间的相互影响

**阻塞(Blocking)：**

当线程占用了临界区的资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。

**非阻塞(Non-Blocking)：**

强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断前向执行，这种情况就是非阻塞。

### 多线程活跃性问题

**死锁(Deadlock)：**

多个线程之间相互占用了需要的资源，那么这个状态将永远维持下去，谁也不可以获得资源从而继续执行。这种情况就是死锁，是最糟糕的一种情况。

**饥饿(Starvation)：**

当一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行，就会出现饥饿的情况。这可能是该线程优先级过低或者需要的资源一直被某个资源抢着不放。但与死锁相比，饥饿还是有可能在未来的一段时间内解决的。

**活锁(Livelock)：**

当多个线程遇到某个共同需要的资源，都因为非优先的原因将资源让个其他线程时，就会产生活锁。这时资源会不断在多个线程跳动，而没有一个线程可以拿到所有资源而正常执行。

## 并发级别

由于临界区的存在，多线程之间的并发必须受到控制。

- 阻塞(Blocking)
- 无饥饿(Starvation-Free)
- 无障碍(Obstruction-Free)
- 无锁(Lock-Free)
- 无等待(Wait-Free)

## JMM

JMM的关键技术点都是围绕多线程的原子性、可见性和有序性来建立的。

**原子性(Atomicity)：**

原子性是指一个操作是不可以中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

**可见性(Visibility)：**

可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。

**有序性(Visibility)：**